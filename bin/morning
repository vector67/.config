#!/usr/bin/env zsh
# morning — gather yesterday's activity from mail, calendar, GitHub, and Jira
# Usage: morning [--hours N] [--no-mail] [--no-calendar] [--no-github] [--no-jira] [--claude]

set -euo pipefail

SCRIPT_DIR="${0:a:h}"

# ── Defaults ──────────────────────────────────────────────────────────────────
LOOKBACK_HOURS=""
SKIP_MAIL=false
SKIP_CALENDAR=false
SKIP_GITHUB=false
SKIP_JIRA=false
PIPE_TO_CLAUDE=false

# ── Parse flags ───────────────────────────────────────────────────────────────
while [[ $# -gt 0 ]]; do
  case $1 in
    --hours)      LOOKBACK_HOURS="$2"; shift 2 ;;
    --no-mail)    SKIP_MAIL=true;      shift ;;
    --no-calendar) SKIP_CALENDAR=true; shift ;;
    --no-github)  SKIP_GITHUB=true;    shift ;;
    --no-jira)    SKIP_JIRA=true;      shift ;;
    --claude)     PIPE_TO_CLAUDE=true; shift ;;
    -h|--help)
      echo "Usage: morning [--hours N] [--no-mail] [--no-calendar] [--no-github] [--no-jira] [--claude]"
      exit 0 ;;
    *) echo "Unknown flag: $1" >&2; exit 1 ;;
  esac
done

# ── Calculate lookback ───────────────────────────────────────────────────────
# Default: previous working day at noon. --hours overrides this.
if [[ -z "$LOOKBACK_HOURS" ]]; then
  DOW=$(date +%u)  # 1=Mon .. 7=Sun
  case $DOW in
    1) DAYS_BACK=3 ;;  # Monday    -> Friday
    7) DAYS_BACK=2 ;;  # Sunday    -> Friday
    *) DAYS_BACK=1 ;;  # Tue-Sat   -> previous day
  esac
  LOOKBACK_SINCE=$(date -v-${DAYS_BACK}d -v12H -v0M -v0S +%s)
  NOW=$(date +%s)
  LOOKBACK_HOURS=$(( (NOW - LOOKBACK_SINCE) / 3600 ))
  LOOKBACK_LABEL="since $(date -v-${DAYS_BACK}d '+%A') at 12:00"
else
  LOOKBACK_LABEL="last $LOOKBACK_HOURS hours"
fi

# ── Load secrets (API tokens, not in global env) ─────────────────────────────
SECRETS_FILE="$HOME/.config/zsh/.secrets/tokens"
[[ -f "$SECRETS_FILE" ]] && source "$SECRETS_FILE"

# ── Temp files for parallel jobs ──────────────────────────────────────────────
TMPDIR_MORNING=$(mktemp -d)
trap 'rm -rf "$TMPDIR_MORNING"' EXIT

# ── 1. Calendar ───────────────────────────────────────────────────────────────
fetch_calendar() {
  local out="$TMPDIR_MORNING/calendar.md"
  if $SKIP_CALENDAR; then
    echo "" > "$out"
    return
  fi

  cat > "$out" <<'HEADER'
## Today's Calendar

HEADER

  local events
  events=$(swift "$SCRIPT_DIR/calendar-today.swift" 2>/dev/null) || true

  if [[ -z "$events" ]]; then
    echo "No events today." >> "$out"
  else
    echo "| Event | Start | End | Calendar |" >> "$out"
    echo "|-------|-------|-----|----------|" >> "$out"
    echo "$events" >> "$out"
  fi
}

# ── 2. GitHub ─────────────────────────────────────────────────────────────────
fetch_github() {
  local out="$TMPDIR_MORNING/github.md"
  if $SKIP_GITHUB; then
    echo "" > "$out"
    return
  fi

  if ! command -v gh &>/dev/null; then
    echo -e "## GitHub\n\n\`gh\` CLI not found. Install with \`brew install gh\`." > "$out"
    return
  fi

  cat > "$out" <<'HEADER'
## GitHub

HEADER

  local gh_user
  gh_user=$(gh api user --jq '.login' 2>/dev/null) || {
    echo "Not authenticated with \`gh\`. Run \`gh auth login\`." >> "$out"
    return
  }

  # My open PRs (use GraphQL to get reviewDecision and isDraft which gh search prs doesn't support)
  local my_prs
  my_prs=$(gh api graphql -f query='
    {
      search(query: "is:pr is:open author:@me", type: ISSUE, first: 50) {
        nodes {
          ... on PullRequest {
            number
            title
            isDraft
            repository { nameWithOwner }
            reviewDecision
            url
          }
        }
      }
    }
  ' --jq '.data.search.nodes[] | "| #\(.number) | \(.title) | \(.repository.nameWithOwner) | \(if .isDraft then "DRAFT" else .reviewDecision // "PENDING" end) | \(.url) |"' 2>/dev/null) || true

  local pr_count=0
  [[ -n "$my_prs" ]] && pr_count=$(echo "$my_prs" | wc -l | tr -d ' ')

  echo "### My Open PRs ($pr_count)" >> "$out"
  if [[ -n "$my_prs" ]]; then
    echo "" >> "$out"
    echo "| # | Title | Repo | Status | URL |" >> "$out"
    echo "|---|-------|------|--------|-----|" >> "$out"
    echo "$my_prs" >> "$out"
  else
    echo "None." >> "$out"
  fi

  # PRs awaiting my review
  echo "" >> "$out"
  local review_prs
  review_prs=$(gh search prs --review-requested="$gh_user" --state=open --json number,title,repository,createdAt,url \
    --jq '.[] | "- [ ] **\(.repository.nameWithOwner)#\(.number)** \(.title) — opened \(.createdAt | split("T")[0]) — \(.url)"' 2>/dev/null) || true

  local review_count=0
  [[ -n "$review_prs" ]] && review_count=$(echo "$review_prs" | wc -l | tr -d ' ')

  echo "### PRs Awaiting My Review ($review_count)" >> "$out"
  if [[ -n "$review_prs" ]]; then
    echo "" >> "$out"
    echo "$review_prs" >> "$out"
  else
    echo "None." >> "$out"
  fi

  # Notifications summary
  echo "" >> "$out"
  echo "### Notifications" >> "$out"
  local notifs
  notifs=$(gh api notifications --jq '
    [.[] | .reason] | group_by(.) | map({reason: .[0], count: length})
    | .[] | "- \(.reason): \(.count)"
  ' 2>/dev/null) || true

  if [[ -n "$notifs" ]]; then
    echo "" >> "$out"
    echo "$notifs" >> "$out"
  else
    echo "None." >> "$out"
  fi
}

# ── 3. Apple Mail ─────────────────────────────────────────────────────────────
fetch_mail() {
  local out="$TMPDIR_MORNING/mail.md"
  if $SKIP_MAIL; then
    echo "" > "$out"
    return
  fi

  cat > "$out" <<'HEADER'
## Email (Apple Mail)

HEADER

  local messages
  messages=$(osascript -e "
    set lookbackSeconds to $LOOKBACK_HOURS * 3600
    set cutoff to (current date) - lookbackSeconds
    set maxMessages to 50
    set msgCount to 0
    set output to \"\"

    tell application \"Mail\"
      set allAccounts to every account
      repeat with acct in allAccounts
        repeat with mbox in mailboxes of acct
          if name of mbox is \"INBOX\" then
            set msgs to (every message of mbox whose date received > cutoff)
            repeat with msg in msgs
              if msgCount ≥ maxMessages then exit repeat
              set senderName to extract name from sender of msg
              set subj to subject of msg
              set dt to date received of msg
              set isRead to read status of msg
              set readMark to \"\"
              if not isRead then set readMark to \"**UNREAD**\"

              set m to (month of dt as integer)
              set d to day of dt
              set h to text -2 thru -1 of (\"0\" & (hours of dt as text))
              set mn to text -2 thru -1 of (\"0\" & (minutes of dt as text))
              set dateStr to (m as text) & \"/\" & (d as text) & \" \" & h & \":\" & mn

              set output to output & \"| \" & senderName & \" | \" & subj & \" | \" & dateStr & \" | \" & readMark & \" |\" & linefeed
              set msgCount to msgCount + 1
            end repeat
          end if
        end repeat
      end repeat
    end tell
    return (msgCount as text) & linefeed & output
  " 2>/dev/null) || true

  if [[ -z "$messages" ]]; then
    echo "Could not access Mail.app (not running or no permission)." >> "$out"
  else
    local count="${messages%%$'\n'*}"
    local table="${messages#*$'\n'}"
    echo "$count message(s) in the last $LOOKBACK_HOURS hours." >> "$out"
    echo "" >> "$out"
    if [[ -n "$table" ]]; then
      echo "| Sender | Subject | Date | Unread |" >> "$out"
      echo "|--------|---------|------|--------|" >> "$out"
      echo "$table" >> "$out"
    fi
  fi
}

# ── 4. Jira ───────────────────────────────────────────────────────────────────
fetch_jira() {
  local out="$TMPDIR_MORNING/jira.md"
  if $SKIP_JIRA; then
    echo "" > "$out"
    return
  fi

  cat > "$out" <<'HEADER'
## Jira

HEADER

  if [[ -z "${JIRA_API_TOKEN:-}" ]] || [[ -z "${JIRA_BASE_URL:-}" ]] || [[ -z "${JIRA_EMAIL:-}" ]]; then
    cat >> "$out" <<'SETUP'
Jira not configured. To enable:

1. Go to https://id.atlassian.com/manage-profile/security/api-tokens
2. Create a classic API token
3. Copy the template and fill in values:
   ```
   cp ~/.config/zsh/.secrets/tokens.template ~/.config/zsh/.secrets/tokens
   ```
4. Run `morning`
SETUP
    return
  fi

  local jql='assignee=currentUser() AND statusCategory in ("To Do", "In Progress") ORDER BY updated DESC'
  local encoded_jql
  encoded_jql=$(python3 -c "import urllib.parse,sys; print(urllib.parse.quote(sys.argv[1]))" "$jql")

  local response
  response=$(curl -s --max-time 10 \
    -u "${JIRA_EMAIL}:${JIRA_API_TOKEN}" \
    -H "Content-Type: application/json" \
    "${JIRA_BASE_URL}/rest/api/3/search/jql?jql=${encoded_jql}&fields=key,summary,status,priority,updated&maxResults=50" \
    2>/dev/null) || true

  if [[ -z "$response" ]]; then
    echo "Could not reach Jira API." >> "$out"
    return
  fi

  local since
  since=$(date -u -v-${LOOKBACK_HOURS}H '+%Y-%m-%dT%H:%M:%S')

  local tickets
  tickets=$(echo "$response" | python3 -c "
import sys, json
from datetime import datetime
try:
    data = json.load(sys.stdin)
    if 'errorMessages' in data:
        print('Jira API error: ' + '; '.join(data['errorMessages']))
        sys.exit(0)
    issues = data.get('issues', [])
    if not issues:
        print('No open tickets assigned to you.')
    else:
        since = '$since'
        recent = []
        older = []
        for i in issues:
            f = i['fields']
            updated = f.get('updated', '')[:19]
            if updated >= since:
                recent.append(i)
            else:
                older.append(i)

        def format_table(issues):
            lines = []
            lines.append('| Key | Summary | Status | Priority |')
            lines.append('|-----|---------|--------|----------|')
            for i in issues:
                f = i['fields']
                key = i['key']
                summary = f.get('summary', '')[:60]
                status = f.get('status', {}).get('name', '?')
                priority = f.get('priority', {}).get('name', '?')
                lines.append(f'| {key} | {summary} | {status} | {priority} |')
            return '\n'.join(lines)

        if recent:
            print(f'#### Recently Updated ({len(recent)})')
            print()
            print(format_table(recent))
            print()
        if older:
            print(f'#### Other Open ({len(older)})')
            print()
            print(format_table(older))
        elif not recent:
            print('No open tickets assigned to you.')
except Exception as e:
    print(f'Error parsing Jira response: {e}')
" 2>/dev/null) || true

  if [[ -n "$tickets" ]]; then
    echo "$tickets" >> "$out"
  else
    echo "Error fetching Jira tickets." >> "$out"
  fi
}

# ── Run all sources in parallel ───────────────────────────────────────────────
fetch_calendar &
fetch_github &
fetch_mail &
fetch_jira &
wait

# ── Assemble output ──────────────────────────────────────────────────────────
TODAY=$(date '+%A, %d %B %Y')
TIME=$(date '+%H:%M')

output="# Morning Catchup - $TODAY
> Data gathered at $TIME. Lookback: $LOOKBACK_LABEL.
> Slack: use Claude Code with Slack MCP plugin for Slack updates.
"

for section in calendar github mail jira; do
  content=$(<"$TMPDIR_MORNING/$section.md")
  if [[ -n "$content" ]]; then
    output="$output
$content
"
  fi
done

# ── Output or pipe to Claude ─────────────────────────────────────────────────
if $PIPE_TO_CLAUDE; then
  echo "$output" > /tmp/morning-catchup.md
  claude -p "$(cat ~/.config/bin/morning-prompt.md)" < /tmp/morning-catchup.md
else
  echo "$output"
fi
